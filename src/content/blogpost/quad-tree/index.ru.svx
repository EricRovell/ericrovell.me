---
cover: "/img/cover-quad-tree.png"
created: 2023-01-17T15:19:00.000Z
description: "Познакомимся со структурой данных, являющейся примером пространственной базой данных."
draft: true
keywords: [ "data structure", "javascript" ]
lang: ru
layout: blogpost
slug: "дерево-квадрантов"
title: "Дерево квадрантов"
---

<script>
	import { CardSketch, Details } from "@components"
	import * as Interactive from "./interactive"
</script>

Дерево квадрантов — древовидная структура данных, имеющая по 4 потомка на каждый внутренний узел. Дерево квадрантов часто используется для рекурсивной разбивки плоскости на квадранты или области. Форма данных, хранящихся на крайних узлах, определяется непосредственно приложением и представляют собой «единицу пространственной информации».

Обычно квадранты представляют из себя квадраты или прямоугольники, но могут иметь и произвольную форму.

Все разновидности данной структуры данных имеют следующие свойства:

- Они разбивают пространство на адаптивные "ячейки" - квадранты;
- Каждая ячейка имеет предельную вместимость, при превышении которой ячейка делится;
- Форма дерева следует пространственной декомпозиции.

Разновидности деревьев могут быть систематизированы в зависимости от представляемых данных, например это могут быть области, точки, отрезки или кривые. Так же важной характеристикой является зависимость порядка обработки данных и формы самого дерева.

Мы познакомимся с деревом квадрантов на примере дерева с квадратными ячейками, содержащими данные в виде точек плоскости.

## Проблема

Рассмотрим применимость дерева квадрантов на практическом примере. Пусть в некоторой ограниченной плоскости имеются `n` движущихся объектов. Задача состоит в определении столкновения объектов в некоторый момент времени.

Для решения поставленной задачи необходимо рассчитать расстояние от каждого объекта до всех остальных. Другими словами, алгоритмическая сложность будет квадратичной: `O(n^2)`, ведь если имеется `n` объектов, то необходимо проверить расстояние целых `n * n` раз.

На самом деле, большую часть проверок можно было бы избежать, если бы мы неким образом имели возможность разграничить слишком удалённые объекты, пересечение с которыми крайне маловероятно. Другими словами, необходимо иметь возможность получать информацию о том, какие объекты находятся в некоторой произвольной области.

<Interactive.ComparingObjects />

В этом нам и поможет дерево квадрантов. Построив дерево для плоскости и предварительно обработав каждый объект, оно позволит нам получать информацию об объектах, находящихся в произвольной области; по итогу будет лишь необходимо провести проверку для части объектов. Этот подход позволит снизить алгоритмическую сложность до `O(n log n)` - логарифмической, в числах - для тысячи объектов количество необходимых операций снижается примерно до *трёх тысяч*. Важно подчеркнуть: с *миллиона* до *трёх тысяч*. Серьёзное увеличение производительности, даже с учётом затрачиваемых ресурсов на построение дерева.

Таким образом, с помощью дерева квадрантов, хранящего координаты объектов, можно решать целый ряд других подобных задач, основанных на пространственном расположении, например, определение ближайшего (отдалённого) объекта от заданного.

## Демонстрация

С учётом использования форм таких "ячеек" как прямоугольники или квадраты, дерево разбивает плоскость на квадранты - напоминающиие собой четверти декартовой системы координат. С ростом вложенности дерева, квадранты разбиваются рекурсивным образом, плоскость делится на всё меньшие области:

<Interactive.QuadTreeDepth />

Пример выше визуально напоминает собой таблицу и даёт мало представления о дереве квадрантов. Рассмотрим более наглядный пример. Коснувшись области, мы можем добавить объект - точку. При последовательном добавлении всё большего количества объектов и превышении предельной вместимости, квадранты будут разбиваться, формируя дерево. В итоге, ни в одной ячейке гарантированно не будет содержаться количество точек, чем квадрант мог бы в себя вместить.

<Interactive.QuadTreeViz />

Увидев, как формируется дерево и что оно из себя представляет, настало время воспользоваться им по назначению. Дерево квадрантов напоминает "пространственную базу данных". Мы можем сделать запрос, указав область и дерево квадрантов укажет на объекты, находящиеся в указанной области. Область, конечно же, может иметь произвольную форму и размеры.

На примере ниже, сформировано дерево квадрантов из ста случайно расположенных точек. При наведении на плоскость будет отображена область в форме прямоугольника или окружности заданных размеров. Лишь точки, находящиеся непосредственно во внутренней части области, будут менять размер и окраску.

<Interactive.QuadTreeQuery />

Таким образом, наглядно демонстрируется результат запроса дереву квадрантов. Мы получаем доступ к информации в зависимости от местоположения на плоскости, что позволяет более эффективно решать поставленные задачи.

### Пример использования

Дерево квадрантов используется на сайте в разеделе ["Визуализации"](/ru/sketch) - моделировании поведения стаи.

<div style="width: min(15ch, 100% - var(--space-3); height: min-content;">
	<CardSketch
		cover="/img/cover-flocking.png"
		description="Flocking modeling"
		title="Flocking"
		url="/ru/sketch/flocking"
	/>
</div>

Дерево в данном случае является оптимизацией, что включена по умолчанию. Необходимость в использовании данной структуры данных заключается в формировании различного рода сил, движущих членом стаи. Силы формируются на основе соседей, в первую очередь, их отдалённости. Более далёкие соседи вкладывают заметно низкое влияние, которым можно пренебречь в целях оптимизации.

Таким образом, каждый член стаи обладает таким параметром как "восприятие", представляющим собой расстояние, за пределами которого другие члены стаи перестают оказывать влияние. На основе координат члена стаи и области, задаваемой "восприятием", дерево квадрантов позволяет узнать лишь о тех членах стаи, которые должны оказывать существенное влияние.

Благодрая дереву квадрантов производительность анимации заметно возрастает. Этому можно убедиться, отключив оптимизацию и увеличив количество членов стаи.

## Имплементация

### Псевдокод

Данный псевдокод демонстрирует один из способов реализовать дерево квадрантов с прямоугольными по форме квадрантами и хранящим данные в виде точек.

Для работы с деревом необходимые следующие вспомогательные структур данных:

```typescript
// Представление точки или вектора на плоскости.
struct Point {
	float x;
	float y;

	function construct(float x, float y): Point;
}

// Представление прямоугольника, выровненного по координатным осям.
struct Rect {
	Point center;
	float width;
	float height;

	function construct(Point center, float width, float height): Rect;
	function contains(Point coordinate): boolean;
	function intersects(Rect otherRect): boolean;
}
```

Структура `Rect` в данном случае описывает прямоугольник, но может быть и видоизмененна для представления других фигур. Важно верно реализовать методы `contains` и `intersects` для обнаружения точек внутри фигуры и расчёт пересечения других фигур.

Непосредственно класс `QuadTree` представляет собой 4-дерево и корневой узел. Экземпляр класса имеет постоянное значение для предельной вместимости квадрантов, задаваемой изначально.

```typescript
//
class QuadTree {
	// Предельная вместимость квадрантов
	constant int CAPACITY = 4;

	// Границы дерева
	Rect boundary;

	// Хранимые точки в данном узле
	points: Array of Point [ size = CAPACITY ];

	// Потомки
	children: Array of QuadTree [ size = 4 ];

	// Методы
	function construct(Rect boundary): QuadTree;
	function insert(Point p): boolean;
	function query(Rect range): Array of Point;
	private function split(): void;
}
```

Метод `insert` регистрирует точку в соответствующий квадрант дерева, осуществляя разбиение при необходимости:

```typescript
class QuadTree {
	...

	function insert(Point p): boolean {
		// Точка не принадлежит дереву
		if (!boundary.contains(p)) {
			return false
		}

		// Зарегистрировать точку при наличии места
		if (points.size < CAPACITY) {
			points.append(p);
			return true;
		}

		// Произвести разветвление дерева
		if (children[0] == null) {
			split();
		}

		// Зарегистрировать точку в один из узлов дерева
		each children as child {
			if (child.inser(p)) {
				return true;
			}
		}

		// По каким-то причинам регистрация точки не осуществлена
		// Этого не должно происходить
		return false;
	}
}
```

Метод `query` осуществляет запрос в заданной области и возвращает все точки, входящие в этот диапазон:

```typescript
class QuadTree {
	...

	query(Rect range): Array of Point {
		// Массив под результат запроса
		items: Array of Point;

		// Запрашиваемая область не совпадает с квадрантом
		if (!boundary.intersects(range)) {
			return items;
		}

		// Проверить точки этого уровня дерева
		each points as point {
			if (range.contains(point)) {
				items.append(point);
			}
		}

		// Нет потомков, прекращаем
		if (children[0] == null) {
			return items;
		}

		// Добавляем все точки потомков
		each children as child {
			child.query(range);
		}

		return items;
	}
}
```

Приватный метод `split` осуществляет разбивку дерева. Реализация метода зависит не только от формы квадрантов дерева, но и от представления. Например, прямоугольник можно задать с помощью координат вершин на одной диагонали либо координатой центра и половиной величины ширины и высоты. Метод `split` должен сформировать координаты дочерних квадрантов на основе используемого представления.

### Реализация на TypeScript

Как и прежде, для начала реализуем вспомогательные структуры данных. Экземпляр `Point`, помимо координат, имеет значение `data` для хранения наших данных. В таком случае, точка является "обёрткой" над данными для регистрации в дереве квадрантов.

```ts
/**
 * Представление точки или вектора на плоскости.
 */
class Point<Data = unknown> {
	readonly x: number;
	readonly y: number;
	readonly data?: Data;

	constructor(x: number, y: number, data?: Data) {
		this.x = x;
		this.y = y;
		this.data = data;
	}
}
```

Границы представляют собой прямоугольник, выровненный вдоль осей координат. В данном случае используется представление прямоугольника через координату верхней левой вершины и значений длин его сторон.

Метод `contains` позволяет проверить, входит ли данная точка в область границы. Для этого нужно убедиться, что координаты точки находятся с внутренней стороны каждой из сторон прямоугольника.

Метод `intersects` позволяет проверить пересечение границы с другой. Суть проверки сводится к тому, чтобы ни одна из сторон прямоугольника не отдалялась от соответственной стороны другого прямоугольника.

```ts
/**
 * Представление прямоугольной границы, выровненной вдоль осей координат
 *  - `x`, `y` - координаты верхней-левой вершины;
 *  - `w` - значение ширины;
 *  - `h` - значение высоты.
 */
export class Rectangle {
	readonly x: number;
	readonly y: number;
	readonly w: number;
	readonly h: number;

	constructor(x: number, y: number, w: number, h: number) {
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
	}

	/**
	 * Проверка расположения данной координаты во внутренней области границы.
	 */
	contains(item: Point): boolean {
		return (
			item.x >= this.x &&
			item.x <= this.x + this.w &&
			item.y >= this.y &&
			item.y <= this.y + this.h
		);
	}

	/**
	 * Проверка на пересечение данной границы с другой.
	 */
	intersects(range: Rectangle): boolean {
		return !(
			this.x >= range.x + range.w ||
			this.x + this.w <= range.x ||
			this.y >= range.y + range.h ||
			this.y + this.h <= range.y
		);
	}
}
```

Теперь можно приступать к реализации дерева. Для практичности добавим некоторые свойства и вспомогательные методы, которых не было в псевдокоде. Например, пользователь может задать ограничение по глубине. Так как будет использоваться рекурсия, то сильная вложенность может ударить по производительности.

Потомки дерева будут храниться в массиве. Так как квадранты прямоугольника напоминают собой четверти в декартовой системе координат, то будет удобно обращаться к квадранту по индексу, с единственным отличием, что нумерация будет идти от нуля.

```ts
class QuadTree<Item extends Point> {
	// область границы данного узла дерева
	readonly boundary: Rectangle;
	// вместимость ячеек дерева
	readonly capacity: number;
	// глубина данного узла дерева
	readonly depth: number;
	// максимальный уровень вложенности дерева
	private readonly depthLimit: number;
	// массив зарегистрированных координат
	items: Item[];
	// потомки дерева
	quadrants: QuadTree<Item>[];

	constructor(capacity: number, boundary: Rectangle, depthLimit = 12, depth = 1) {
		this.boundary = boundary;
		this.capacity = capacity;
		this.depth = depth;
		this.depthLimit = depthLimit;
		this.items = [];
		this.quadrants = [];
	}

	...
}
```

Далее, добавим вспомогательный метод `hasChildren` для проверки наличия потомков:

```ts
class QuadTree<Item extends Point> {
	...

	/**
	 * Проверяет данный узел дерева на наличие потомков.
	 */
	get hasChildren(): boolean {
		return this.quadrants.length > 0;
	}
}
```

Следующим шагом реализуем метод `split` для разбивки дерева. Метод приватный, так как разбивка дерева будет происходить автоматически при определённых обстоятельствах. Метод создаёт четыре новых экземпляра класса `QuadTree` и добавляет их в массив квадрантов данного узла.

```ts
class QuadTree<Item extends Point> {
	...

	/**
	 * Creates children nodes, expanding the `QuadTree` instance.
	 */
	private split(): void {
		const hw = this.boundary.w / 2;
		const hh = this.boundary.h / 2;

		// смещения координат вершины каждого нового квадранта
		const delta = [
			[ hw, 0 ],
			[ 0, 0 ],
			[ 0, hh ],
			[ hw, hh ]
		];

		for (const [ dx, dy ] of delta) {
			this.quadrants.push(new QuadTree<Item>(
				this.capacity,
				new Rectangle(this.boundary.x + dx, this.boundary.y + dy, hw, hh),
				this.depthLimit,
				this.depth + 1
			));
		}
	}
}
```

Теперь реализуем метод `insert` для регистрации координат.

Для начала проверяется, действительно ли данная точка лежит в данной границе. В случае, если у узла нет потомков и имеется свободное место, точка регистрируется в данном узле.

В случае, если у узла уже имеются потомки и не достигнуто предельное значение глубины, дерево разветвляется. На этом этапе все зарегистрированные точки данного узла перерегистрируются вглубь и массив точек очищается. Этот этап необходим для того, чтобы только крайние узлы дерева содержали точки.

В конце концов, точка поочередно пытается зарегистрироваться в одном из квадрантов, пока её не примет один из них.

Метод возвращает булеву величину для отождествления успешности операции.

```ts
class QuadTree<Item extends Point> {
	...

	/**
	 * Регистрирует координату в экземпляре `QuadTree`.
	 */
	insert(item: Item): boolean {
		if (!this.boundary.contains(item)) {
			return false;
		}

		if (!this.hasChildren && this.items.length < this.capacity) {
			this.items.push(item);
			return true;
		}

		if (!this.hasChildren && this.depth < this.depthLimit) {
			this.split();

			// Перерегистрация прежде зарегистрированных точек вглубь
			for (const thisItem of this.items) {
				for (const quadrant of this.quadrants) {
					if (quadrant.insert(thisItem)) {
						break;
					}
				}
			}

			this.items = [];
		}

		for (const quadrant of this.quadrants) {
			if (quadrant.insert(item)) {
				return true;
			}
		}

		return false;
	}
}
```

Напоследок, осталось реализовать метод `query` для запроса данных дерева. Данные будут отбираться из узлов рекурсивно. На каждой глубине вызова функции вторым параметром передаётся массив с отобранными данными, пока финальным вызовом функция не вернёт итоговый массив:

```ts
class QuadTree<Item extends Point> {
	...

	/**
	 * Запрашивает данные, хранящиеся в экземпляре дерева в заданной области.
	 */
	query(range: Rect, items: Item[] = []): Item[] {
		// Нет пересечения, соответственно, нет и результатов
		if (!range.intersects(this.boundary)) {
			return items;
		}

		for (const item of this.items) {
			if (range.contains(item)) {
				items.push(item);
			}
		}

		// если имеются потомки, но в них могут находиться данные
		if (this.hasChildren) {
			for (const quadrant of this.quadrants) {
				quadrant.query(range, items);
			}
		}

		return items;
	}
}
```

Собирая всё воедино, получаем следующий код:

<Details>

<svelte:fragment slot="title">
	Итоговый код
</svelte:fragment>

```ts
/**
 * Представление координаты точки или вектора на плоскости.
 */
export class Point<Data = unknown> {
	readonly x: number;
	readonly y: number;
	readonly data?: Data;

	constructor(x: number, y: number, data?: Data) {
		this.x = x;
		this.y = y;
		this.data = data;
	}
}

/**
 * Представление прямоугольной границы:
 *  - `x`, `y` - координаты верхнего левого угла;
 *  - `w` - значение ширины;
 *  - `h` - значение высоты.
 */
export class Rectangle {
	readonly x: number;
	readonly y: number;
	readonly w: number;
	readonly h: number;

	constructor(x: number, y: number, w: number, h: number) {
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
	}

	/**
	 * Проверяет нахождение данной координаты в области границы.
	 */
	contains(item: Point): boolean {
		return (
			item.x >= this.x &&
			item.x <= this.x + this.w &&
			item.y >= this.y &&
			item.y <= this.y + this.h
		);
	}

	/**
	 * Проверяет пересечение данной области с другой областью.
	 */
	intersects(range: Rectangle): boolean {
		return !(
			this.x >= range.x + range.w ||
			this.x + this.w <= range.x ||
			this.y >= range.y + range.h ||
			this.y + this.h <= range.y
		);
	}
}

export class QuadTree<Item extends Point> {
	readonly boundary: Rectangle;
	readonly capacity: number;
	readonly depth: number;
	private readonly depthLimit: number;
	items: Item[];
	quadrants: QuadTree<Item>[];

	constructor(capacity: number, boundary: Rectangle, depthLimit = 12, depth = 1) {
		this.boundary = boundary;
		this.capacity = capacity;
		this.depth = depth;
		this.depthLimit = depthLimit;
		this.items = [];
		this.quadrants = [];
	}

	/**
	 * Проверяет наличие у данного узла дерева потомков.
	 */
	get hasChildren(): boolean {
		return this.quadrants.length > 0;
	}

	/**
	 * Регистрирует координату в экземпляре дерева.
	 */
	insert(item: Item): boolean {
		if (!this.boundary.contains(item)) {
			return false;
		}

		if (!this.hasChildren && this.items.length < this.capacity) {
			this.items.push(item);
			return true;
		}

		if (!this.hasChildren && this.depth < this.depthLimit) {
			this.split();

			for (const thisItem of this.items) {
				for (const quadrant of this.quadrants) {
					if (quadrant.insert(thisItem)) {
						break;
					}
				}
			}

			this.items = [];
		}

		for (const quadrant of this.quadrants) {
			if (quadrant.insert(item)) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Производит разветвление дерева.
	 */
	private split(): void {
		const hw = this.boundary.w / 2;
		const hh = this.boundary.h / 2;

		const delta = [
			[ hw, 0 ],
			[ 0, 0 ],
			[ 0, hh ],
			[ hw, hh ]
		];

		for (const [ dx, dy ] of delta) {
			this.quadrants.push(new QuadTree<Item>(
				this.capacity,
				new Rectangle(this.boundary.x + dx, this.boundary.y + dy, hw, hh),
				this.depthLimit,
				this.depth + 1
			));
		}
	}

	/**
	 * Запрашивает данные, хранящиеся в экземпляре дерева в заданной области.
	 */
	query(range: Rectangle | Circle, items: Item[] = []): Item[] {
		// boundary.intersects(range) or vice versa?
		if (!range.intersects(this.boundary)) {
			return items;
		}

		for (const item of this.items) {
			if (range.contains(item)) {
				items.push(item);
			}
		}

		if (this.hasChildren) {
			for (const quadrant of this.quadrants) {
				quadrant.query(range, items);
			}
		}

		return items;
	}
}
```

</Details>

## Итоги

Мы рассмотрели один из простейших типов дерева, хранящего координаты точек плоскости. В таком виде деревья используются для индексации данных на плоскости, эффективного обнаружения столкновений, в моделировании. Намного чаще используются типы деревьев, хранящих информацию об областях плоскости, например, в обработке графических данных.

## Ссылки

- [Дерево квадрантов](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D0%BD%D1%82%D0%BE%D0%B2)
- [Интерактивная демонстрация дерева квадрантов](https://jimkang.com/quadtreevis/)
